# ASIC Theory
ASIC stands for Application-Specific Integrated Circuit. It is a type of integrated circuit (IC) that is specially designed for a particular application or use case rather than being a general-purpose chip. ASICs are optimized for specific tasks, and their design is tailored to perform those tasks efficiently and with high performance.

The Github repository documents and tracks the progress for the course Physical Design ASIC(VL508).  

## DAY 0 - Installation

<details>
<summary> <strong> Yosys </strong> - Open-Source RTL Synthesis Tool </summary>

Yosys is a powerful and widely-used open-source RTL synthesis tool that enables designers to convert Verilog RTL code into optimized gate-level representations suitable for ASIC or FPGA implementation. It is designed for digital hardware design and offers a plethora of features, including RTL synthesis, technology mapping, optimization, and formal verification capabilities. With a scripting interface and an active community of users and developers, Yosys provides flexibility, efficiency, and cost-effectiveness for various digital design projects.

**Key Features**:
- RTL Synthesis: Yosys takes Verilog RTL code as input and performs RTL synthesis, generating a gate-level netlist.
- Technology Mapping: The tool maps the RTL design to a specific library of standard cells, allowing optimization for target technologies.
- Optimization: Yosys employs various algorithms to optimize the design for improved performance, area, and power consumption.
- Formal Verification: The tool includes formal verification capabilities to ensure the correctness of the design.
- Scripting Interface: Yosys provides a scripting interface, enabling users to write custom synthesis scripts for specific design flows and optimizations.
- Open-Source and Community-Driven: Yosys is an open-source project with an active community, constantly contributing to its development and improvement.
  
**Installation**

Yosys is installed using the following set of steps.

```bash
$ git clone https://github.com/YosysHQ/yosys.git
$ cd yosys-master 
$ sudo apt install make (If make is not installed please install it) 
$ sudo apt-get install build-essential clang bison flex \
    libreadline-dev gawk tcl-dev libffi-dev git \
    graphviz xdot pkg-config python3 libboost-system-dev \
    libboost-python-dev libboost-filesystem-dev zlib1g-dev
$ make config-gcc
$ make 
$ sudo make install
```
Screenshot after installation-
![yosys](https://github.com/Shant1R/Shant_IIITB/assets/59409568/6ac97051-4660-4722-b384-26eb6aba3260)

</details>

<details>

<summary><strong>Icarus verilog</strong> - Open-Source Verilog Simulation and Synthesis Tool</summary>

Iverilog is a widely-used open-source Verilog simulation and synthesis tool that allows designers to simulate and synthesize digital hardware designs described in Verilog HDL. It offers a comprehensive set of features for both simulation and synthesis, making it a valuable tool for digital design projects of all scales. With its versatility and community-driven development, Iverilog provides an efficient and cost-effective solution for verifying and implementing digital designs.

**Key Features**:
- Verilog Simulation: Iverilog supports simulation of Verilog designs, enabling users to test and verify their digital circuits' functionality.
- Synthesis Support: The tool provides synthesis capabilities, allowing designers to generate gate-level netlists suitable for ASIC or FPGA implementation.
- IEEE Standard Compliance: Iverilog adheres to the IEEE 1364-2005 Verilog standard, ensuring compatibility with a wide range of Verilog designs.
- VPI (Verilog Programming Interface) Support: Iverilog supports VPI, enabling users to write C/C++ programs to interact with the simulation or synthesis process.
- Efficient and Scalable: Iverilog is known for its efficiency, making it suitable for small hobbyist projects as well as large-scale commercial designs.
- Open-Source and Community-Driven: Being an open-source tool, Iverilog benefits from an active community of users and developers, continually improving and enhancing its capabilities.
  
**Installation**

Icarus Verilog also known as iverilog is installed using the following command.

```bash
$ sudo apt-get update
$ sudo apt-get install iverilog

```
Screenshot after installation-
![iverilog](https://github.com/Shant1R/Shant_IIITB/assets/59409568/4f77ee22-b0b3-4c96-9f8e-1b74443579e4)


</details>

<details>
<summary><strong>GTKWave</strong> - Open-Source Waveform Viewer for Digital Simulation</summary>

GTKWave is a popular open-source waveform viewer designed to visualize and analyze simulation results of digital designs. As an essential tool in digital hardware development, GTKWave allows users to examine waveforms generated by Verilog or VHDL simulation, making it easier to debug and verify the behavior of complex digital circuits. With its user-friendly interface and active community support, GTKWave is a valuable asset for engineers and hobbyists involved in digital design and verification projects.

**Key Features**:
- Waveform Visualization: GTKWave provides a graphical interface to display simulation waveforms, helping users gain insights into the behavior of digital circuits.
- Support for Various Formats: The tool supports various waveform formats, including VCD (Value Change Dump), FST (Fast Signal Trace), LXT, and VZT.
- Zoom and Navigation: GTKWave allows users to zoom in and out on specific regions of the waveform and provides convenient navigation tools for easy waveform analysis.
- Signal Grouping: Users can group related signals together, simplifying the visualization of complex designs.
- Cross-Platform Compatibility: GTKWave is available for multiple platforms, including Windows, macOS, and Linux, making it accessible to a wide range of users.
- Extensible and Customizable: Users can extend GTKWave's functionality through scripting and customize the appearance and behavior of the waveform viewer.
- Open-Source and Community-Driven: As an open-source project, GTKWave benefits from continuous community contributions, ensuring the tool's ongoing improvement and relevance

**Installation**

GTKWave is installed using the following commands.

```bash
$ sudo apt update
$ sudo apt install gtkwave
```
Screenshot after installation-
![gtkwave](https://github.com/Shant1R/Shant_IIITB/assets/59409568/ae8c7922-c337-4157-839f-c8f1f62265b2)

</details>


<details>
<summary><strong>OpenSTA</strong> - Open-Source Static Timing Analysis Tool</summary>

OpenSTA is a powerful open-source Static Timing Analysis (STA) tool designed to analyze digital integrated circuits and provide critical timing information. As an essential component of the digital design flow, OpenSTA enables engineers to perform timing verification, identify potential timing violations, and optimize the performance of complex designs. With its versatile features and community-driven development, OpenSTA is a valuable resource for designers working on ASIC or FPGA projects.

**Key Features**:
- Static Timing Analysis: OpenSTA performs static timing analysis to determine the critical paths and timing violations in digital designs.
- Liberty File Support: The tool supports industry-standard Liberty format files, which contain timing information about the standard cells used in the design.
- Path Tracing and Reporting: OpenSTA traces critical timing paths and generates detailed timing reports, highlighting setup and hold violations.
- Constraints Support: Designers can specify timing constraints in the design using standard Synopsys Design Constraints (SDC) files, which OpenSTA interprets during the analysis.
- Highly Scalable: OpenSTA can handle designs of varying sizes, from small digital circuits to large-scale industrial projects, making it suitable for a broad range of applications.
- Interactive Visualization: OpenSTA provides an interactive graphical interface to visualize and navigate through the timing paths in the design.
- Open-Source and Community-Driven: As an open-source project, OpenSTA benefits from contributions and feedback from a community of users and developers, ensuring continuous improvement and adaptability to new technologies.

**Installation**

To install OpenSTA, follow the given github link and download the following prerequisites- 

```bash
https://github.com/The-OpenROAD-Project/OpenSTA
```

```bash
$ sudo apt-get install cmake
$ sudo apt-get install clang
$ sudo apt-get install gcc
$ sudo apt-get install tcl
$ sudo apt-get install swig
$ sudo apt-get install bison
$ sudo apt-get install flex
```

Installation commands for openSTA
```bash
$ git clone https://github.com/The-OpenROAD-Project/OpenSTA.git
$ cd OpenSTA
$ mkdir build
$ cd build
$ cmake ..
$ make
```
Screenshot after installation-
![opensta](https://github.com/Shant1R/Shant_IIITB/assets/59409568/36537253-8d3e-4f7a-9358-35c3f5c04e55)

</details>


<details>
<summary><strong>NGSpice</strong> - Open-Source Circuit Simulation Tool</summary>

Ngspice is a powerful open-source circuit simulation tool that allows engineers, researchers, and hobbyists to analyze and simulate electronic circuits. As a widely-used circuit simulator, Ngspice can handle analog, digital, and mixed-signal circuits, providing valuable insights into circuit behavior, performance, and characteristics. With its extensive set of features and active community support, Ngspice serves as an essential tool for circuit design, analysis, and optimization.

**Key Features**:
- Mixed-Signal Simulation: Ngspice supports mixed-signal simulation, enabling the analysis of circuits containing both analog and digital components.
- Circuit Modeling: The tool supports a wide range of device models, including passive components, diodes, transistors, operational amplifiers, and more.
- Advanced Analysis: Ngspice provides various analysis types, such as DC, AC, transient, and noise analysis, allowing users to evaluate circuit performance under different conditions.
- Extensibility: Users can add custom models, algorithms, and simulation capabilities through scripting and user-defined subcircuits.
- SPICE Compatibility: Ngspice adheres to the SPICE (Simulation Program with Integrated Circuit Emphasis) standard, ensuring compatibility with existing SPICE netlists.
- Cross-Platform Support: Ngspice is compatible with multiple operating systems, including Windows, macOS, and Linux, making it accessible to a broad user base.
- Open-Source and Community-Driven: Being an open-source project, Ngspice benefits from active community contributions, bug fixes, and enhancements, ensuring its continuous development and reliability.

**Installation**

NGSpice is installed using the following commands.

After downloading the tarball from https://sourceforge.net/projects/ngspice/files/ to a local directory, unpack it using:

```bash
$ tar -zxvf ngspice-37.tar.gz
$ cd ngspice-37
$ mkdir release
$ cd release
$ ../configure  --with-x --with-readline=yes --disable-debug
$ make
$ sudo make install
```
Screenshot after installation-
![ngspice](https://github.com/Shant1R/Shant_IIITB/assets/59409568/726fcc95-63eb-4089-87e3-f306cc37d83c)

    
</details>

<details>
<summary><strong>Magic</strong> - Open-Source VLSI Layout and Chip Design Tool</summary>
Magic is a widely-used open-source VLSI (Very-Large-Scale Integration) layout and chip design tool. It offers a versatile and user-friendly environment for designing, editing, and analyzing integrated circuit layouts. As an essential tool in the physical design flow, Magic allows engineers and researchers to create complex IC layouts and verify their correctness before fabrication. With a range of features and active community support, Magic is a valuable asset for digital and analog chip designers and hobbyists.

**Key Features**:
- Layout Editing: Magic provides an intuitive interface for designing and editing integrated circuit layouts, enabling efficient placement and routing of various circuit elements.
- Custom Design Rules: Users can define custom design rules, allowing them to tailor the layout to specific technology nodes and manufacturing processes.
- Hierarchical Design: Magic supports hierarchical design methodologies, enabling the creation of complex designs by organizing circuits into hierarchical blocks.
- Design Rule Checking (DRC): The tool performs design rule checks to identify potential layout errors and violations before the chip fabrication process.
- Extraction and Simulation: Magic allows extraction of parasitic components and supports SPICE netlist simulation for accurate performance evaluation.
- Scripting and Automation: Users can extend Magic's functionality using scripts, automating repetitive tasks and customizing the design flow.
- Cross-Platform Support: Magic is compatible with various operating systems, including Windows, macOS, and Linux, making it accessible to a wide range of users.
- Open-Source and Community-Driven: As an open-source project, Magic benefits from an active community of users and developers, ensuring continuous improvement and adaptability to new design challenges.

**Installation**
  
Magic is installed using the following commands.

```bash
$   sudo apt-get install m4
$   sudo apt-get install tcsh
$   sudo apt-get install csh
$   sudo apt-get install libx11-dev
$   sudo apt-get install tcl-dev tk-dev
$   sudo apt-get install libcairo2-dev
$   sudo apt-get install mesa-common-dev libglu1-mesa-dev
$   sudo apt-get install libncurses-dev
$   git clone https://github.com/RTimothyEdwards/magic
$   cd magic
$   ./configure
$   make
$   sudo make install

```
Screenshot after installation-
![magic](https://github.com/Shant1R/Shant_IIITB/assets/59409568/f5fe09ee-2f15-47c0-b4a6-5a41febf7e76)
    
</details>


<details>
<summary><strong>OpenLANE</strong>- Open-Source Digital ASIC Design Flow</summary>

OpenLane is a comprehensive open-source digital ASIC (Application-Specific Integrated Circuit) design flow that facilitates the design and implementation of complex digital chips. It provides a complete RTL-to-GDSII (RTL to Graphic Design System II) flow, encompassing synthesis, placement, routing, and manufacturing processes. OpenLane streamlines the ASIC design process and enables designers to create custom digital chips with greater efficiency and accessibility. With an extensive set of features and community support, OpenLane is a valuable tool for ASIC designers, researchers, and hobbyists alike.

**Key Features**:
- RTL-to-GDSII Flow: OpenLane offers an end-to-end design flow, starting from RTL synthesis to final GDSII layout generation, ensuring a seamless ASIC design process.
- Synthesis and Optimization: The tool performs RTL synthesis and optimization to generate an efficient gate-level representation of the design.
- Placement and Routing: OpenLane optimizes chip placement and performs routing to connect all the components efficiently.
- DRC and LVS Checks: OpenLane includes design rule checking (DRC) and layout versus schematic (LVS) checks to ensure the design's manufacturability and correctness.
- PDK Integration: The tool integrates with Process Design Kits (PDKs) from various foundries, supporting a wide range of technology nodes and manufacturing processes.
- Scripting and Customization: Users can write scripts to customize various aspects of the design flow and automate repetitive tasks.
- Performance and Area Optimization: OpenLane offers options to optimize the design for performance, area, or power based on the project's requirements.
- Cross-Platform Support: OpenLane is compatible with multiple operating systems, including Windows, macOS, and Linux, making it accessible to diverse design teams.
- Open-Source and Community-Driven: Being an open-source project, OpenLane benefits from continuous community contributions, bug fixes, and enhancements, ensuring its continuous development and improvement.

**Installation**

OpenLane is installed using the following commands.

```bash
$ sudo apt-get update
$ sudo apt-get upgrade
$ sudo apt install -y build-essential python3 python3-venv python3-pip make git
$ sudo apt install apt-transport-https ca-certificates curl software-properties-common
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
$ echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
$ sudo apt update
$ sudo apt install docker-ce docker-ce-cli containerd.io
$ sudo docker run hello-world
$ sudo groupadd docker
$ sudo usermod -aG docker $USER
$ sudo reboot 
```

After Reboot
```bash
$ docker run hello-world
```

```bash
$ cd $HOME
$ git clone https://github.com/The-OpenROAD-Project/OpenLane
$ cd OpenLane
$ make
$ make test
```

Screenshot after installation-
![openlane](https://github.com/Shant1R/Shant_IIITB/assets/59409568/d55be32a-a662-4284-94b0-b0d53af2fbca)

</details>

## DAY 1 - Introduction to Verilog RTL design and Synthesis

<details>
<summary><strong>Open Source simulator iverilog</strong></summary>

Simulator is a tool to verify that the said design adheres to the functionality to its intended specifications. It works by following the input given and changes the output accordingly, thus one can compare the desired output and the output derived for the said inputs.

Simulator architecture schematic diagram -
![Simulator](https://github.com/Shant1R/Shant_IIITB/assets/59409568/11d0647f-499b-4ea9-ab80-8c6ef20da093)

Under the given repository, **Iverilog** is used which is an open source simulator.
- Design is the set of verilog codes with the aim to create a functionality that meets the given specifications. 
- Testbench is the set of code which provides the stimulas or test vectors to the desgin under test to verify the design working.
- It is to be noted multiple inputs can be given the design block and multiple outputs can be derived.
- The testbench is not given any external inputs. Testvectors are given under the testbench itself.
- The output of the simulator is a VCD file, ie. value change dump file which is viewed using **GTKWave** to visualise the waveform.

Simulation flow of Iverilog - 
![workflow](https://github.com/Shant1R/Shant_IIITB/assets/59409568/b67eb2d2-478e-4745-9876-7846de6a01c0)

</details>


<details>
<summary><strong>Introduction to Lab</strong></summary>

Under this, we will go through how to setup the directory and lab for the course and how to access various files and execute.

**Lab Setup**

The first step under the lab setup for the course is to form a seperate directory as VLSI and git clone the course files from the given repository in the code.



```bash
$ cd Documents
$ cd ASICs
$ cd VLSI
$ cd git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git
```

Terminal Window - 
![sky130_gitclone](https://github.com/Shant1R/Shant_IIITB/assets/59409568/8e74128d-3341-4378-9c40-309260327bef)

Upon the cloning, a new folder with the name *sky130RTLDesignAndSynthesisWorkshop* is made. Under this folder, there will be several folders, such as lib which contains the standard set library for sky130 which will be used for the synthesis, verilog_files which contains all the source files and testbenches for the experiments to be done. The contents of each folder can be seen by going into the directory and entering ls.


**Working with iverilog and gtkwave - MUX**

Under this, we go over how load files on iverilog and visualise using gtkwave. The terminal is opened and the directory is set to the verilog_files, where various source files and their respective testbenches are stored. Under this example we will execute the mux using good_mux.v and check the functionality using gtkwave to visualise the dumpfile generated. Both the source file and testbench are loaded to iverilog. 

```bash
$ cd VLSI
$ cd sky130RTLDesignAndSynthesisWorkshop
$ cd verilog_files/
$ ls
$ iverilog good_mux.v tb_good_mux.v
$ ./a.out
$ gtkwave tb_good_mux.vcd
```

Screenshot of the terminal - 
![good_mux_terminal](https://github.com/Shant1R/Shant_IIITB/assets/59409568/06396f49-0e6c-487b-8408-82491557a852)

Waveform on GTKWave - 
![good_mux_gtk](https://github.com/Shant1R/Shant_IIITB/assets/59409568/cc8ec616-ac4d-4bc1-801f-0e680247ad69)

The waveform on gtkwave is used to check the variations in the output with the input.

**Code Explaination - MUX**

To edit the code, one can directly open the files or use gvim. The code to access both the source and testbech is given

```bash
$ gvim tb_good_mux.v -o good_mux.v
```


Editor window - 
![code_good_mux](https://github.com/Shant1R/Shant_IIITB/assets/59409568/cf8ca326-755a-4664-ae0b-8c01b8e94723)

There can be multiple ways to generate a mux. Under the given source code. it checks for the select line, if sel is 1, the output follows the input line 1 else it follows input line 0. Under the testbench, the inputs are set as reg and output as wire. The testbench has no primary inputs like the design source code. It instantiate the source code as uut - unit under test, any name can be used. Under the testbench, the dumpfile is generated for visualisation. The input variables are set and the toggled periodically and sets an end time. 

</details>


<details>
<summary><strong>Introduction to Yosys and Logic synthesis</strong></summary>

The RTL design is the behavioural model of the said specification written in an HDL language. For mapping this code to a hardware circuit comes the synthesis. The RTL code is translated to gate level using the front end libraries that are .lib files, through synthesis the netlist file is derived. 

The front end library is also called .lib, which can be explained as a collection for modules for the logic gates for the mapping. It contains various types of the same logic gate, such as 2 and 3 input and gates, and modules for the same gate with different execution speed, which can de decided upon the usecase and required specification. The speed of the gates depends the load, which for digital circuits are capacitors, thus charging and discharging of capacitors determine the speed of the gate, thus the system. For faster speed, we need transistor with more current sourcing capacity. Thus the need for wider transistors. But wider transistors enables faster processes with the trade off of power and area. Narrow transistors comsumes lesser area and power, but comes with bigger delays. Thus the choice of the gate models is made accordingly. The time delat should small enough to cover the propogation delay and setup times and at the same time large enough that it doesn't cause a hold crisis, that is its bigger than the hold time of the next gate in process.


One has to guide the synthesizer for the required execution time, ie, the use of faster and slower transistor models while mapping. This is known as constraints.    

The synthesizer used under this coursework is Yosys. 

Yosys setup flow-
![yosys1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/35698376-e603-40eb-b5a4-a84965620587)

The design block has the function read_design and .lib  has a read_liberty function which reads the design file and .lib respectively. The netlist block has the fucntion read_netlist which upon execution generates the netlist file for the given design. It is to note design file and netlist file are two different representations for the same given specification.  

Synthesis verification flow - 
![yosys2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/8c89fc9e-7d6a-426e-b55f-3927db75d7e7)

To verify the synthesis output, we use the iverilog simulator which is given the netlist and testbench as inputs, attain a vcd file, which is visualised using gtkwave. The output on the gtkwave with the netlist file should be the same as in the case of RTL simulation. Since the primary inputs and outputs in case of RTL designs and netlist design remains the same, the same testbench can be used to verify the design. 


</details>



<details>
<summary><strong>Lab using Yosys and Sky130 PDKs</strong></summary>

Under this section, we go through how to invoke the synthesizer yosys and synthesize the design. For the demonstration, we have taken the synthesis of mux, the good_mux.v file, which we have previously simulated before. 

- Step one is to go to the directory for the verilog files and invoke yosys synthesizer.

```bash
$ cd Documents/ASICs/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files/
$ yosys
```

![yosys_lab_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/24e98dd7-b81c-4398-a0cb-f5d5bf872813)

- Now we read the .lib using *read_liberty* and the path is set to the .lib files.
- The behavourial model of mux is read using *read_verilog* followed by determining the module name to be synthesized.
- The netlist is generated by *abc -liberty* followed by the path to .lib which specifies what gates are to be linked. Thus the RTL file is converted to netlist.
- The logic being realised can be view using *show*.

```bash
 read_liberty -lib ~/Documents/ASICs/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
 read_verilog good_mux.v
 synth -top good_mux
 abc -liberty ~/Documents/ASICs/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files/sky130_fd_sc_hd__tt_025C_1v80.lib
 show
```

![yosys_lab_2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/e3861c1c-4493-4fe1-822b-7e5179d95ab0)

- The netlist file is wriiten using *write_verilog* followed by the name for the file.
- Gvim edittor is used view the netlist file.

```bash
 read_verilog good_mux_netlist.v
 !gvim good_mux_netlist.v  
```

![yosys_lab_3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/c201daec-bc2b-44f7-83c5-77ab3dd37e9d)

- It can seen that the netlist file has extra informations, thus to generate a simple netlist file we add an extra switch.
- After *write _verilog* we add *-noattr* before the file name.
- We attain a simpler netlist representation for mux.

```bash
 read_verilog -noattr good_mux_netlist.v
 !gvim good_mux_netlist.v
```

![yosys_lab_4](https://github.com/Shant1R/Shant_IIITB/assets/59409568/a917b533-9932-46bd-adfb-032cea61855b)

  
</details>

## DAY 2 - Timing libs, Hierarchical vs Flat synthesis and effective flop coding styles

<details>

<summary><strong>Introduction to .lib</strong></summary>
Under this section, we get a better insight regarding .lib. We have the general overview that it stores the models of all the standards cells, various variations and flavours as per the need of specification provided. Getting an insight into the .lib file, we start with the file name -  

*sky130_fd_sc_hd__tt_025C_1v80*

The name sky130 represemts that the library is based on 130nm technology. Under the nomenclature, we define PVT - process, voltage and temperature. Process refers to the variations due to the fabrication, ie. there will variations in the silicon fabricated even by the same machine. There is variation due to the voltage and temperature as well. Silicon is very sensitive to temperature. All these 3 determines how the silicon is going to perform. We aim to design such that silicon works in all the conditions, across various variations. These three are indicated under the name, tt stands for typical process, 25c indicates the temperature - 25C and 1v80 indicates the voltage of 1.80volts.  It is to be noted, all the models under the said library are designed for the given PVT parameters.

We open the .lib file using gvim to go through various other informations it provides.

![lib_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/f1a46b64-c496-4fd4-82e7-ef43e091964b)

- It defines the technology begin used "CMOS" and the delay model as "table_lookup"
- it defines the units for various parameters and quanities, such as, 1ns for time, 1V for voltage, 1mA for current, 1kohm for resistance and 1pF for capacitance.
- It defines the operating conditions as "tt_025C_1v80".

We take an example for a cell to understand the contents. Taking the example of a21110i cell. 

![lib_2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/9996a4bc-1328-4436-91f0-551a17dd7d72)

- The given cell executes the logic for 5 inputs, *and* for the first two inputs and *or* it with the next three inputs, finally *not* the final expression.
- Logic implemented --> !((A1&A2)|B1|C1|D1)
- Since we got 5 inputs, there are 32 possible outputs. The .lib file contains the power consumption and timing details for all the possibilities.


Considering a two input *and* gate, and compare different two input and gate.

![lib_3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/717b8741-8d21-413e-95b2-968c38eef551)

- The lib files conatins the power and timing information for the 4 possible outcomes.
- All three taken cells are 2 input and gates, but differ in their areas, and2_4 has a larger area than area2_2 and consequently more than and2_0.
- Having a larger area refers to the use of a wider cell. Wider cells will be faster, but consumes more power. This can be seen in the datials under the lib file.


  
</details>


<details>

<summary><strong>Heirarchial vs Flat Synthesis</strong></summary>

Under this section, we go over what is heirchial synthesis and flat synthesis. For this, we  have taken the case of multiple_modul2s.v from verilog files to have a better unstanding.
```bash
  shant@shant:~/Documents/ASICs/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files$ gvim multiple_modules.v
```
![hvf_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/16523aee-77cd-4f09-95b0-d8e56f9920da)

Gate level diagram 

![hvf_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/0f16a24d-c1ea-4d38-891b-5d16f5dbcd13)

We go into the directory for verilog files and invole the model.

```bash
$ cd Documents/ASICs/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
$ yosys
read_liberty -lib ~/Documents/ASICs/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog multiple_modules.v
synth -top multiple_modules
abc -liberty ~/Documents/ASICs/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show multiple_modules
```

- As we hit show, we expect to attain a similar schematic we had drew in the previous image.
  
![hvf_2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/a55d9d7a-ab21-430c-8174-770f422220f5)

- We get the image of the top module.
- We don't get to see the and and or gates. We see the modules u1 and u2, which are the instances of the gates.
- **This type of design is called an heirarchial design.**
- We generate the netlist file for the design.

```bash
write_verilog -noattr multiple_modules_hier.v
!gvim multiple_modules_hier.v
```

![hvf_3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/620892c8-1681-4d46-911e-1e7a2e4a8ee7)

- In the netlist generated, it is observed that the hierarchy is maintained. The top module has instances of sub moduke 1 and 2, and the two modules are seperately defined implementing the *and* and *or* gates.
- It is to be more, since this is CMOS technology, we implement the gates using a *nand* gate with inverted inputs for *or* gate and *nor* gate with inverted inputs for *and* gate.

Now we will look into flat design techcnique.

```bash
flatten
show multiple_modules
```

![hvf_5](https://github.com/Shant1R/Shant_IIITB/assets/59409568/9428f816-7ab6-49f6-a3d4-0c527719364c)

```bash
write_verilog -noattr multiple_modules_flat.v
!gvim multiple_modules_flat.v
```

![hvf_4](https://github.com/Shant1R/Shant_IIITB/assets/59409568/a9476f35-4ba0-4caa-a035-893227557410)

- In the new netlist, we don't see any instances of submodules such as u1 and u2.
- We get direct instances of *and* and *or* gates under the flat design.
- **This type of design is known as flat desigin techniques.**

We saw how to synthesis the top module, now we will look into synthesis of submodules.

```bash
$ cd Documents/ASICs/VLSI/sky130RTLDesignAndSynthesisWorkshop/verilog_files
$ yosys
read_liberty -lib ~/Documents/ASICs/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog multiple_modules.v
synth -top sub_module1
abc -liberty ~/Documents/ASICs/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```

![hvf_6](https://github.com/Shant1R/Shant_IIITB/assets/59409568/48519618-7a15-4695-a075-c0ca9acb4853)

- We only see submodule 1, we don't get to see the multiple module or submodule 2.

Reason for having synthesis at submodule level ->
- In case my design has multiple instances of same module, we prefer to synthesis it once and the replicate it as many times required and stitch it to the main module.
- It supports *divide and conqure appraoch*. In case the design is massive, we give small portions to the tool instead of the entire design. This helps in generating an optimised netlist for the complete desgin and supports reusebility.


</details>


<details>

<summary><strong>Various Flop Coding Styles and Optimizations</strong></summary>

Under this section, we go through all the various types of flops available and how to design and code them efficiently. All the required files are presen in the folder verilog_files. 

To understand the need of flops, we refer the example of a simple circuit with delays as 2ns for *and* gate and 1ns for *or* gate.

![ff_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/d9bd0c57-605b-4c7b-8724-297ab5b812d6)

- Considering the input goes from 0 to 1 for a and b and simultaneously, 1 to 0 for c.
- Ideally for the transition from (001) to (110), the output should have been a constant at 1, but because of the delay, we get outout as 0 for a brief period of 2ns.
- This is called a **glitch**.

![ff_2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/f75878fe-d695-44cf-b498-f516b7d2a028)
  
- More the number of combinational circuits, more number of glitches appear, giving a glitchy output.
- To avoid this, we need an element to store the value. Comes the flops into picture.
- We use a D flipflop. They are a storage element. They are placed between combinational circuits and changes value only at clock edge.

![ff_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/eb9ab8c7-a87c-4ca0-89ec-ecb36361032e)

  
- Now even if the the input of the clock is glitching, we attain a stable output.
- **NOTE** --> We need to initailise the flops, else the combinational circuits gives a garbage value. For this purpose we have reset and set pins. They can be asynchoronous and synchronous.

Types of flops
- Flops can be designed to be asynchronous or synchronous. It depends on whether the flop is sensitive to the reset and set parameters.
- Under asynchronous, the flop is sensitive to the reset or set, ie the design checks for them and the moment, reset is encountered, the output is pulled to **0** irrespective of the clock. For asynchronous set, the output is pulled to **1**.
- The circuit design and timing diagram along with verilog code is displayed under the image below under column 1.
- Under the case of synchronous reset, the output is pulled to **0** at the next clock cycle. The design and timing diagram along the verilog code is shown under the column 2 of the image below.
- Sync reset can be understodd as the input is pulled to 0, thus output becomes 0 for next clock cycle.

![ff_2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/77037d1a-28bd-434f-9ed4-ddb57613973c)

- Under column of the image above, shows the verilog code and circuit structure for a d flipflop that accounts for sync as well as async resets.


Now, we go through simuations of async reset, async set and sync async reset and observe the waveforms using gtkwave to have a better understand.

***Code --> dff_asyncres.v***

```bash
module dff_asyncres ( input clk ,  input async_reset , input d , output reg q );
always @ (posedge clk , posedge async_reset)
begin
	if(async_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```
- Upon execution on terminal using iverilog and gtkwave

![dff_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/59e993cf-c5f4-40b7-b66d-085c17be91c7)

- We can observe that the output q goes to 0 when the reset is encountered.
- Now we synthesis the design using yosys.

![dff_syn_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/67fbc5d1-0016-4c7d-9917-66bddc85bb39)

***Code --> dff__async_set.v***

```bash
module dff_async_set ( input clk ,  input async_set , input d , output reg q );
always @ (posedge clk , posedge async_set)
begin
	if(async_set)
		q <= 1'b1;
	else	
		q <= d;
end
endmodule
```

- Upon execution on terminal using iverilog and gtkwave

![dff_2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/e13a4ed4-ea09-4148-9b09-b828893bce82)

- We can observe that the output q goes to 1 as soon as we encounter the set irrespective of that clock.
-Now we synthesis the design using yosys. 

![dff_syn_2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/8070cd5f-035b-433b-a16b-b3ff3bc9c232)


***Code --> dff_syncres.v***

```bash
module dff_syncres ( input clk ,  input sync_reset , input d , output reg q );
always @ (posedge clk )
begin
	if(sync_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```

- Upon execution on terminal using iverilog and gtkwave

![dff_4](https://github.com/Shant1R/Shant_IIITB/assets/59409568/344634b7-6aec-486b-9dd4-7ce7d7a9ec61)

- It is observed that the output q is set to 0 at the next clock pulse when the reset is encountered, thus it is the case of sync reset.
- Now we synthesis the design using yosys.

![dff_syn_3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/83e54797-cb25-4734-97e9-2269e25b2f39)


***Code --> dff_asyncres_syncres.v***

```bash
module dff_asyncres_syncres ( input clk , input async_reset , input sync_reset , input d , output reg q );
always @ (posedge clk , posedge async_reset)
begin
	if(async_reset)
		q <= 1'b0;
	else if (sync_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```

- Upon execution on terminal using iverilog and gtkwave

![dff_3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/2bda822d-c54f-4207-b2ba-4b61aae705ba)

- We can observe that output q goes to 0 when encountered the async reset and waits for the next clock edge to set q to 0 in case of encounter with sync reset.
- Now we synthesis the design using yosys.

![dff_syn_4](https://github.com/Shant1R/Shant_IIITB/assets/59409568/6e929a9e-8a5b-4e7f-993c-39882bc6b734)
  
</details>


<details>

<summary><strong>Interesting Optimisations</strong></summary>

Under this section we look into two interesting cases and how they are executed and designed.

First we look into mul2.v

- Code for mul2.v

```bash
module mul2 (input [2:0] a, output [3:0] y);
	assign y = a * 2;
endmodule
```

- The block diagram and the truth table for the executed logic is shown under.
   
![sp_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/774a0cd2-2144-4bce-bab3-b498db7ef417)

- From these, we are able to infer that the logic requires the input to be multiplied with 2, and upon checking the output it is the input with 1'b0 padding.
- Thus the design for the logic needs no hardware to be mapped.
- We will confirm this using yosys.

![sp_2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/ee8c1ac5-23e4-4339-a6d5-9affa8741ffa)

- From the yosys synthesis, we observe the number of cells in design is 0 and there is no hardware to be mapped. These have been highlighted in the picture above.
- The schematic attained shows a similar result.
- This was done in case of multiplication with 2. For multiplication with 4, we give 2'b00 padding and for 8, we give 3'b000 padding. This goes on.

Now, we look into another special case. 
- Condider a 3bit number a[2:0], and the logic to be implemented is that the output y[5:0] is equal to 9 times of a[2:0].
- Code for execution

```bash
module mult8 (input [2:0] a , output [5:0] y);
	assign y = a * 9;
endmodule
```

- Logic explaination

![sp_3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/44bbe634-8835-4d0e-b783-6edd05ce9717)

- Multiplcation with 9 can be seen as multiplication with 8 and plus 1.
- We know multiplication with 8 is equal to 3'b000 padding, and adding the same 3 bit number to the padded number comes of as concatanation of {a,a}.
- Thus there are no standard cell required for the design. We verify this using yosys.

![sp_4](https://github.com/Shant1R/Shant_IIITB/assets/59409568/7da4d7a5-2ea6-4b55-a5d3-95103956e2dd)

- We see that there are no standard cells required.
- We see the concatanation operation done in the netlist. 


 
</details>

## DAY 3 - Combinational and Sequential Optimization

<details>

<summary><strong>Introduction to Optimizations</strong></summary>
Under this section, we will look into how to optimise our design for combinational logic as well as sequentail logic designs. The optimised designs are defined in terms of area and power savings.

<br></br>
**Methods for Combinational logic Optimization**
- Direct Method --> *Constant Propogation*
- Boolean logic meth0d --> *K-map or Quine McKluskey*

**Constant Propogation**

Consider the logic circuit under figure(I), if we ground input a, ie, a=0, the entire expression goes from y=(a.b+c)' to y=c'.

![opt_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/98ab0ccf-8237-4a23-a956-8754e4da080c)

- For implementing figure(I), we require in total of 6 transitors under CMOS technology. Whereas, for the final ciruit under fig(II) with the given constraints, we require only 2 transistors under CMOS tech. Thus we can see that we have reduces the number of transistors, hence better optimised.

**Boolean Logic**

Consider we try to implement a logic using tertiary operator, such as **y = a?(b?c:(c?a:0)):(!c)**. This can be mapped using three 2 input muxs as shown in the figure

![opt_2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/de299ebb-619d-4a39-ab9e-667dd355c99b)

- The output generated using the circuit shown is **y = a'.b' + a.[ b.c + b'.a.c ]**, which is clear that is not optimised. The logic can be optimised using K-maps. The optimised logic comes as **~( a ^ b )**.


The synthesis tool performs these optimisations to come up with an effective and optimised design.


**Methods for Sequential logic Optimization**
- Basic --> Sequential Constant Propogation
- Advanced methods.

**Sequential Constant Propogation**

Under this the flop can be optimised in case the output of the flop is constant, else if the output of flop changes, the entire flop is retained. To understand this we take two examples

- The input of D ff is grounded, ir d=0, and the reset parameter is given. Here even if the reset is given or not the output output of the flop is constant at 0, hence the overall outcome is constant.

![opt_3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/6fd15cfc-6bfe-4c8e-a452-71439110468f)


- Now taking the same circuit, but instead of reset, we give set. Now when the set is 1, the flop output follows set. As soon as set is removed, the output goes to 0 at the next positive clock edge. Thus now we can't remove the flop from design, Thus we retain the flop. 

![opt_4](https://github.com/Shant1R/Shant_IIITB/assets/59409568/5dd4680f-b2dc-4596-9916-f359ec6bcfbd)

**Advanced Methods for Sequential logic Optimisation**

- **State optimization** in ASIC design is about finding the best trade-offs among performance, power efficiency, area utilization, and other design objectives to create an effective and efficient custom integrated circuit for a particular application.
- **Re-timing** is the technique used to optimize the timing performance of a digital circuit by moving registers (flip-flops) to different locations within the circuit without changing its functionality. The primary goal of retiming is to improve the critical path delay, which is the longest path through the logic circuit that determines the maximum operating frequency.
- **Sequential logic cloning** or **flip-flop cloning** or **state machine cloning** is the technique used to replicate or duplicate certain portions of sequential logic circuits. This technique is employed to improve performance, reduce critical path delays, or optimize power consumption in a design without altering its functional behavior.
  
</details>


<details>

<summary><strong>Combinational logic Optimizations</strong></summary>

Under this section, we go through 6 lab experiments and synthesis them using yosys. The code used to optimise the design is given below. It is executed before mapping the design to the lib file. 
```bash
opt_clean -purge
```

*opt_clean* remove unused cells and wires. The *-purge* switch removes internal nets if they have a public name. This command identifies wires and cells that are unused and removes them. This command can be used to clean up after the commands that do the actual work.

In case of multiple models, it is important to flatten the design then followup with optimization.


**Lab 1 - opt_check.v**

- RTL file 
```bash
module opt_check (input a , input b , output y);
	assign y = a?b:0;
endmodule
```
- Optimised hardware generated after synthesis on yosys
![op_cc_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/a5e82f35-01cc-468b-bd40-351a665daefb)

**Lab 2 - opt_check2.v**

- RTL file 
```bash
module opt_check2 (input a , input b , output y);
	assign y = a?1:b;
endmodule
```
- Optimised hardware generated after synthesis on yosys
![op_cc_2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/1e5cca73-9352-4920-9ef2-484be87ddf9e)

  
**Lab 3 - opt_check3.v**

- RTL file 
```bash
module opt_check3 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
endmodule
```
- Optimised hardware generated after synthesis on yosys
![op_cc_3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/3711aae4-aab1-4ea8-bf34-04a746b20ac9)

  
**Lab 4 - opt_check4.v**

- RTL file 
```bash
module opt_check4 (input a , input b , input c , output y);
 assign y = a?(b?(a & c ):c):(!c);
 endmodule
```
- Optimised hardware generated after synthesis on yosys
![op_cc_4](https://github.com/Shant1R/Shant_IIITB/assets/59409568/7897969a-87c5-4891-b486-570e25f47e90)

  

**Lab 5 - multiple_module_opt.v**

- RTL file 
```bash
module sub_module1(input a , input b , output y);
 assign y = a & b;
endmodule


module sub_module2(input a , input b , output y);
 assign y = a^b;
endmodule


module multiple_module_opt(input a , input b , input c , input d , output y);
wire n1,n2,n3;

sub_module1 U1 (.a(a) , .b(1'b1) , .y(n1));
sub_module2 U2 (.a(n1), .b(1'b0) , .y(n2));
sub_module2 U3 (.a(b), .b(d) , .y(n3));

assign y = c | (b & n1); 


endmodule
```
- Optimised hardware generated after synthesis on yosys
![op_cc_5](https://github.com/Shant1R/Shant_IIITB/assets/59409568/ddf3154d-2677-4324-a973-04e0a36712a2)

  

**Lab 6 - multiple_module_opt.v2**

- RTL file 
```bash
module sub_module(input a , input b , output y);
 assign y = a & b;
endmodule



module multiple_module_opt2(input a , input b , input c , input d , output y);
wire n1,n2,n3;

sub_module U1 (.a(a) , .b(1'b0) , .y(n1));
sub_module U2 (.a(b), .b(c) , .y(n2));
sub_module U3 (.a(n2), .b(d) , .y(n3));
sub_module U4 (.a(n3), .b(n1) , .y(y));


endmodule
```
- Optimised hardware generated after synthesis on yosys
![op_cc_6](https://github.com/Shant1R/Shant_IIITB/assets/59409568/1d8f999f-09be-4c04-a452-8b1e8ab23e85)

  
</details>


<details>

<summary><strong>Sequential logic Optimizations</strong></summary>

Under this section, we go over optimisation for sequential logic designs. 

**Lab 1 - dff_const1.v**

- RTL file 
```bash
module dff_const1(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b0;
	else
		q <= 1'b1;
end

endmodule
```

- Simulation report using iverilog and gtkwave

![opt_dff_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/7541a097-4e52-4a8d-ab0f-c59a1bd8933c)

- Optimised design using yosys

![opt_dff_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/7b9a8f1f-4839-48de-8a12-0fcbb08599e8)
![opt_dff_3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/281fe4a8-e6c8-442c-a7a7-23109e0d2ddf)

- It is seen that the design an one dff in the model.
  
**Lab 2 - dff_const2.v**

- RTL file 
```bash
module dff_const2(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b1;
	else
		q <= 1'b1;
end

endmodule
```

- Simulation report using iverilog and gtkwave

![opt_dff_2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/8dbb8cae-05ed-446d-af80-f116b36a9d3f)

- Optimised design using yosys

![opt_dff_2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/dc3143f4-71ff-4417-8461-9f7d54c9c14a)


- It is seen that the design has been optimised to have no dff in the final models.



**Lab 3 - dff_const3.v**

- RTL file 
```bash
module dff_const2(input clk, input reset, output reg q);
module dff_const3(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```

- Simulation report using iverilog and gtkwave

![opt_dff_4](https://github.com/Shant1R/Shant_IIITB/assets/59409568/142eb530-bb2f-4f8c-8ac4-185ea1016609)

- Optimised design using yosys

![opt_dff_7](https://github.com/Shant1R/Shant_IIITB/assets/59409568/9afb81da-87c4-4e0a-8b09-952e3a1879cb)



**Lab 4 - dff_const4.v**

- RTL file 
```bash
module dff_const4(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b1;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```

- Simulation report using iverilog and gtkwave

![opt_dff_5](https://github.com/Shant1R/Shant_IIITB/assets/59409568/e084b37b-d947-49cc-8a52-b3a419242f82)

- Optimised design using yosys

![opt_dff_8](https://github.com/Shant1R/Shant_IIITB/assets/59409568/9657f9e9-2820-4786-b2db-f82bc1473cc0)



**Lab 5 - dff_const5.v**

- RTL file 
```bash

module dff_const5(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b0;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```

- Simulation report using iverilog and gtkwave

![opt_dff_6](https://github.com/Shant1R/Shant_IIITB/assets/59409568/540885ac-eb0c-42a0-beef-615026a62dff)

- Optimised design using yosys

![opt_dff_9](https://github.com/Shant1R/Shant_IIITB/assets/59409568/40a57160-8f3c-4b5e-a0c6-3af9423b2b1b)

</details>


<details>

<summary><strong>Sequential Optimizations for Unused Outputs</strong></summary>

Under this section, we look into how yosys synthesizer optimises the design in case of unused bits in the output. For this we have taken a 3 bit counter. In case 1, only the LSB is taken as final output, thus the first two are left unused. In case two, we take the entire 3 bits as output. 

![sp_opt_3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/6f9028ff-4752-45f1-a7c6-839b377ae326)


**Case 1 -- only using count[0]**

- RTL code

```bash
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = count[0];

always @(posedge clk ,posedge reset)
begin
	if(reset)
		count <= 3'b000;
	else
		count <= count + 1;
end

endmodule
```
- Synthesis using yosys

![sp_opt1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/031afa01-1030-42d7-8f83-097505eb9cf0)

- In the image, it is observed that is integrated only one dff for optimised hardware design.

**Case 2 -- using all three bits count[2], count[1] and count[0]**

- RTL code for the changed file.

```bash
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = count[2:0] == 3'b100;

always @(posedge clk ,posedge reset)
begin
	if(reset)
		count <= 3'b000;
	else
		count <= count + 1;
end

endmodule
```
- Synthesis using yosys

![sp_opt2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/1c332dd0-3c46-4868-8a89-778f559a3631)
![sp_opt](https://github.com/Shant1R/Shant_IIITB/assets/59409568/4c97002c-e620-492b-88ec-b2323052d963)

- In the yosys generation, we see the design has encorporated 3 dff for the 3 bit counter.
- It is evident that the yosys synthesizer optimizes for the unsed bits in the output. This so important as illustrated because it saves a ton of space, and speed, and improves efficiency of the final design.

</details>



## DAY 4 - GLS, Blocking vs Non-blocking and Synthesys-Simulation Mismatch

<details>

<summary><strong>GLS, Synthesis-Simulation Mismatch and Blocking/Non-blocking Statements</strong></summary>

**GLS -- Gate Level Simualation**

We have run the simulation using iverilog before, where we feed in the RTL file and the testbench. GLS is when we simulate the netlist file in place of RTL file.
- RTL file and Netlist file are logically the same, hence netlist fits in testbench perfectly.
- RTL file and netlist file has the same inputs and outputs.
- GLS simuation is performed to verilfy the logic after synthesis.
- GLS simulation also accounts for the timing specifications of the design. For this GLS has to be run with delay annotation.

GLS flow using iverilog.

![gls_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/43ace40b-f4ce-4788-9903-b8971a5b9d92)

We know we perform GLS to check for the logic validation after synthesis. Thus there might be some mistmatch that happens during the synthesis.

**Why does Synthesis and Simulation mismatch happen?**
- Missing sensitivity list
- Blocking vs Non-blocking statements
- Non standard verilog coding practices

*Missing Sensitivity List*

To understand this we take examples for a mux with different sensitivity. 
- Code 1`

```bash
module mux1 (input sel , i0, i1 ,
output reg y);

always@(sel)
begin
if(sel)
	y=i1;
else
	y=i0;
end

endmodule
```
- Code 2

```bash
module mux (input sel , i0, i1 ,
output reg y);

always@(*) 
begin
if(sel)
	y=i1;
else
	y=i0;
end

endmodule
```

- Mux 1 is sensitive to changes is changes in latches, ie the output y will change only at the changes of sel. Thus the changes of inputs i1 and i0 are not displayed in the output.
- Mux 2 is sensitive to all three, so when high sel, output covers all changes in i1, and for low sel, all changes in i0 are covered.
- Now, the simulation and synthesis of mux 2 wont have any mismatch.
- But mux1 will have mismatch,as simulators work on sensitivity list and the simulation will behave as a *double edge triggered latch*, while the synthesizer converts the logic into netlist and doesn't look into sensitivity list, thus synthesis will behave as a *2 input MUX*.

*Blocking vs Non-blocking Statement*

The difference between blocking and non-blocking type of assignment comes under the always block
- Blocking assignment(=) -> Can be understood as serial execution, ie statements are executed one by one
- Non-blocking assignment(<=) -> Can be understood as parallel execution, ie the RHS operation of the assignments are performed first, then the value is assigned to LHS simultaneously.
- Now, we take example of a 2 bit shift registor. 

![bnb_1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/48aaad73-3e39-4dd5-a6c9-4920e7be1a7b)


Now taking a case of combinational cicuit into consideration.

- Code A 
```bash
always @(*)
begin
  y  =  q0 & c;
  q0 =  a  | b;
end

```
- Code B
```bash
always @(*)
begin
  q0 =  a  | b;
  y  =  q0 & c;
end
```

- Upon simulation, both the code A and B gives the same output.
- Upon synthesis, the design varies as code A, uses the old value of q0, thus incorporates a flop, whereas design B uses the new value, thus no flop required.
- This mismatch was generated due to swaping the statement positions.


</details> 


<details>

<summary><strong>Lab on GLS Synthesis-Simulation Mismatch</strong></summary>
We take two examples of mux to have a better understanding of the importance. Here, we focus on mismatch between simulation and synthesis. 

We first take the case of a good mux using ternary operator.

- RTL code -> ternary_operator_mux.v

```bash
module ternary_operator_mux (input i0 , input i1 , input sel , output y);
	assign y = sel?i1:i0;
endmodule
```

- Simulating using iverilog and gtkwave

![gls1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/ea079af7-b4c3-4ccf-b87c-3fdf0bfcddc9)

- Now we synthesize it using yosys

![gls2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/d31164bc-88d1-4138-9a8d-7a52ee24ec5f)

- Running GLS using the netlist file generated using yosys

![gls3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/9baf0702-1bfd-42ac-82cb-a08ca356a02f)

- It is clear that both the simulation waves are same.

Now we take the example of the bad mux, we discussed before -> one that acts as a double triggered latch during simulation.

- RTL code -> bad_mux.v
```bash

module bad_mux (input i0 , input i1 , input sel , output reg y);
always @ (sel)
begin
	if(sel)
		y <= i1;
	else 
		y <= i0;
end
endmodule

```

- Simulating using iverilog and GTKwave

![gls4](https://github.com/Shant1R/Shant_IIITB/assets/59409568/c912f00c-8cae-4680-88ed-2a1175e40fed)

- Synthesizing the design using yosys.

![gls5](https://github.com/Shant1R/Shant_IIITB/assets/59409568/97465d38-ccf1-4182-9c5d-1ce6ffb1cef4)

- Running GLS using the generated netlist file on iverilog and gtkwave.

![gls6](https://github.com/Shant1R/Shant_IIITB/assets/59409568/1823fca8-48ce-4cc8-91bb-e9bdd128f1b4)

- Under this, we see a clear mismatch between the simulation and synthesis designs. The RTL file and netlist files aren't the same logic implemention. This happened due to the sensitivity listing under the RTL file.

 
</details>


<details>

<summary><strong>Lab on Synthesis-Simulation Mismatch and Blocking statements</strong></summary>

Under this section, we will look into the mismatch between simulation and synthesis caused due to the blocking statements

- RTL code for blocking_caveat.v

```bash
module blocking_caveat (input a , input b , input  c, output reg d); 
reg x;
always @ (*)
begin
	d = x & c;
	x = a | b;
end
endmodule
```

- Running the simulation using iverilog and gtkwave

  ![cav1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/00dbba46-94a0-4cb5-9492-ce60a415677b)

- we attain a waveform, which does not matches with the expected output waveform for *d=((a|b).c)*. Thus the simulation logic is failing.
- Now we carry on to synthesize the design using yosys.
- We generate a netlist file.

![cav2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/603d1964-f978-4dc9-a75d-b5ee5bc66f72)

- Running GLS on the netlist file using iverilog and gtkwave.

![cav3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/21a0d969-9d66-4298-846e-d2057bfd8ce9)

- It is seen that the waveform matches with the expected output for *d=((a|b).c)*.
- There is clear mismatch between the simulation and synthesis in this case. This happended coz we used blocking statements, and while simulation, the design makes a flop, which wasn't the intention of the original design.
  
 
</details>


## DAY 5 - If, case, for loop and for generate


<details>

<summary><strong>If Case Constructs</strong></summary>

Under this section, we will look into if and case statements for verilog coding. These statements are always given under an **always** block. Thus the output is always a reg type. 

***If-else condotions*** are known as priority logic statments.

- General syntax for if-else condtions
```bash
if(Condition 1)
	<Statement 1>
else if(Condition 2)
	<Statement 2>
else if(Condition 3)
	<Statement 3>
else
	<Statement 4>
end
```
- It can be inferred that, when the condition 1 is valid, statement 1 is of the highest priority, and the rest of the condtions aren't checked for.
- Similarly, we check for which condtion falls true. In case none do, the else block statements takes highest priority.
- The if-else statements can be designed using muxs as shown-->

![if1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/faa370f8-a116-4237-8ad5-00bc1e5b0f97)

**Cautions while using if-else**
- In case we miss the else block, it can cause an inferred latch.
- It is a latch that wasn't intended in the design.

![if2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/3b103d4f-d2c5-48cb-b701-0ed93d7cbec3)

- **Note** --> We can use this as a design advantage in cartain cases, such as a **counter** design, where we have an inferred latch to store the previous counts.

![if3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/6ad9ca43-67eb-4b3d-b43b-327d5b0aabaf)

***Case Statement***

- Case statement looks for equality for the select line variable.
- RTL syntax
```bash
 always @(*)
 begin
   case(sel)
     2'b00: begin
	    ------
	    ------
	    end
     2'b01: begin
            ------
     	    ------	
	    end
     default:
   endcase
 end
```
- In the syntax above we have taken a 2 bit select variable, thus there are 4 cases to be determined.
- In case we dont address all four cases, the remaining two cases will form a latch with the previous output.
- In order to avoid these inferred lateches, it is practiced to always have a default block.

![case1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/df44cbf2-60cf-4b2e-83b4-e9a8d75f8544)

- Another point to take note of --> avoid partial assignments, else this might cause inferred latch formations.
- Example to show the condtion of partial assignments.

```bash
reg [1:0] sel;
always @(*)
 begin
   case(sel)
     2'b00: begin
             x=a;
             y=b;
            end
     2'b01: begin
             x=c;
            end 
     default: begin
               x=d;
               y=b;
             end
   endcase
  end
```
- The hardware design for the given RTL file.

 ![case2](https://github.com/Shant1R/Shant_IIITB/assets/59409568/d9e110da-5117-43f1-9451-c8eaf04583fb)

- To avoid this it is important we assign all the variables in all the given cases and default case and also avoid overlapping cases.

 
</details>


<details>

<summary><strong>Hands on "Incomplete if case"</strong></summary>

Now we look into how an incomplete if-else statement cause the hardware design to stray from the intended logic under LAB 1 and LAB 2.

**LAB 1**
- RTL code for incomp_if.v
```bash
module incomp_if (input i0 , input i1 , input i2 , output reg y);
always @ (*)
begin
	if(i0)
		y <= i1;
end
endmodule
```
- RTL Simulation using iverilog and gtkwave.

![incomp-if1](https://github.com/Shant1R/Shant_IIITB/assets/59409568/ce6e93bf-754b-4b38-8087-7c71f4770c90)

- Synthesis using yosys

![incomp-if](https://github.com/Shant1R/Shant_IIITB/assets/59409568/4efd3236-84d8-4582-9d02-c72ab6046b5f)

- It is seen that there has been an inferred latch formation due to incomplete if-else condtional statements.

**LAB 2**


- RTL code for incomp_if2.v
```bash

module incomp_if2 (input i0 , input i1 , input i2 , input i3, output reg y);
always @ (*)
begin
	if(i0)
		y <= i1;
	else if (i2)
		y <= i3;

end
endmodule
```
- RTL Simulation using iverilog and gtkwave.

![incomp_if3](https://github.com/Shant1R/Shant_IIITB/assets/59409568/5e3c6abe-6b52-4f5b-9b66-ca59548b77f1)

- Synthesis using yosys

![incomp_if4](https://github.com/Shant1R/Shant_IIITB/assets/59409568/3f86455b-c55b-4554-8ea9-ca7882cfff21)

- It is seen that there has been an inferred latch formation due to incomplete if-else condtional statements.

 
</details>


<details>

<summary><strong>Hands on "Case"</strong></summary>

In ths section, we look into various situations with case statement under simulation and synthesis.

**Lab 1 --> without *default***

Under this, we look into the formation of inffered latch due to omission of default case.

- RTL file for *incomp_case.v*
```bash
module incomp_case (input i0 , input i1 , input i2 , input [1:0] sel, output reg y);
always @ (*)
begin
	case(sel)
		2'b00 : y = i0;
		2'b01 : y = i1;
	endcase
end
endmodule
```

- Running RTL simulation using iverilog and GTKwave.

![Screenshot from 2023-08-15 13-56-36](https://github.com/Shant1R/Shant_IIITB/assets/59409568/fac1bcb5-9a60-4c3a-8e10-efd55f987202)

- Now running the synthesis for the RTL file using yosys

![Flowchart - Frame 31](https://github.com/Shant1R/Shant_IIITB/assets/59409568/731a1af7-5380-4a5f-b2a2-99e77aa453f4)

- It is seen, due to the omission of the default case, we have an inferred latch in the hardware design.

**Lab 2 --> with *default***

Under this, we will look into how the default case removes the formation of a latch in the design.

- RTL file for *comp_case.v*
```bash


module comp_case (input i0 , input i1 , input i2 , input [1:0] sel, output reg y);
always @ (*)
begin
	case(sel)
		2'b00 : y = i0;
		2'b01 : y = i1;
		default : y = i2;
	endcase
end
endmodule
```

- Running simulaion using iverilog and gtkwave.

![Screenshot from 2023-08-15 14-06-42](https://github.com/Shant1R/Shant_IIITB/assets/59409568/53ec3d94-2408-453e-8f67-bd7b91f53ff5)

- Now running the synthesis using yosys.

![Screenshot from 2023-08-15 14-07-27](https://github.com/Shant1R/Shant_IIITB/assets/59409568/38c1d4b8-c989-452f-add2-849e2e7b238f)

- Under this case, we see no inferred latch formations. 

**Lab 3 --> *Partial case assignment***

Under this, we look into how partial case assignments cause the formation of inferred latch.

- RTL file for *partial_case_assign.v*

```bash
module partial_case_assign (input i0 , input i1 , input i2 , input [1:0] sel, output reg y , output reg x);
always @ (*)
begin
	case(sel)
		2'b00 : begin
			y = i0;
			x = i2;
			end
		2'b01 : y = i1;
		default : begin
		           x = i1;
			   y = i2;
			  end
	endcase
end
endmodule
```

- Running simulation using iverilog and gtkwave.

![Screenshot from 2023-08-15 14-50-26](https://github.com/Shant1R/Shant_IIITB/assets/59409568/71f3a128-80a0-42b1-b21e-06aaa851ad56)

- Running synthesis using yosys.

![Flowchart - Frame 32](https://github.com/Shant1R/Shant_IIITB/assets/59409568/fb8fa107-f9a0-46b5-8af6-cfc3083d726d)

- It is noticed that we have a latch in the design of the hardware even when we didn't had one in RTL file. This is due to the partial case assignment.

**Lab 4 - The bad Case**

Under this, we look into the case of a bad case, which has simulation synthesis mismatch due to the improper assignment for case 1'b1?. This leads to formation of inferred latches.

- RTL file for bad_case.v

```bash
module bad_case (input i0 , input i1, input i2, input i3 , input [1:0] sel, output reg y);
always @(*)
begin
	case(sel)
		2'b00: y = i0;
		2'b01: y = i1;
		2'b10: y = i2;
		2'b1?: y = i3;
		//2'b11: y = i3;
	endcase
end

endmodule￼
```

- Running simulation using iverilog and GTKwave.

![Screenshot from 2023-08-15 22-46-42](https://github.com/Shant1R/Shant_IIITB/assets/59409568/d5ded630-8581-43d3-a50e-d9af3b9ce07e)

- Running synthesis using yosys.

![Screenshot from 2023-08-15 22-49-30](https://github.com/Shant1R/Shant_IIITB/assets/59409568/c1b558b9-c94c-451c-97a9-4d915e2916d9)

- Running GLS using iverilog and GTKwave from the netlist attained under synthesis.

![Screenshot from 2023-08-15 22-52-53](https://github.com/Shant1R/Shant_IIITB/assets/59409568/44977eec-2281-4508-8b8d-bb10243dc47e)

- We can see the mismatching under GLS and RTL simulation. This is due to improper assignment and formation of latches which weren't a part of the intended logic design. 

</details>


<details>

<summary><strong>For loop and For generate</strong></summary>

In this section, we look into programming concept of looping in verilog. There are two methods of looping in verilog-->

- for loop
- generate followed by for loop

**For loop**
- It is always written under *always* block.
- This is used to replicate and processing expressions under logic. 
- This is not used to replicate and instantiate hardwares functions.
- Example with syntax for looping

```bash
input reg [31:0] inp;
integer i;
always @(*)
begin
  for (i=0;i<32;i=i+1)
  begin
    if(i == sel)
      y = inp[i];
  end
end 
```

- Under this example we take a 32 bit input, and we loop in and take the output for y bit wise using for loop. 

  
**Generate for loop**
- This statement is always written outside the *always* block.
- This is used to replicate and instantiate hardware, as example in case one needs 100 and gates under some implementation.
- Example with syntax for *generate for* loop.

```bash
genvar i;
generate
  for(i=0;i<3;i=i+1)
    begin
      and u1 (.a(a[i]) , .b(b[i]) , .y(y[i]));
    end
endgenerate
```

- In this example, we instantiate *and* gate u1 3 times using generate for loop.

 
</details>



<details> 

<summary><strong>Hands on "for loop" & "for generate"</strong></summary>
 
</details>








# References

1. https://github.com/YosysHQ/yosys
2. https://github.com/steveicarus/iverilog
3. https://github.com/gtkwave/gtkwave
4. https://github.com/The-OpenROAD-Project/OpenSTA
5. https://github.com/ngspice/ngspice
6. https://github.com/RTimothyEdwards/magic
7. https://github.com/The-OpenROAD-Project/OpenLane
8. https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop
9. https://miro.com/
